use crate::dto::{CreateUserRequest, User, UserRole};
use crate::entity::users;
use crate::repository::UserRepository;
use async_trait::async_trait;
use bcrypt::{hash, verify, DEFAULT_COST};
use sea_orm::{DatabaseConnection, EntityTrait, ActiveModelTrait, Set, ColumnTrait, QueryFilter};
use std::sync::Arc;
use uuid::Uuid;

/// PostgreSQL implementation of user repository (using SeaORM)
pub struct PostgresUserRepository {
    db: Arc<DatabaseConnection>,
}

impl PostgresUserRepository {
    pub fn new(db: DatabaseConnection) -> Self {
        Self {
            db: Arc::new(db),
        }
    }
}

#[async_trait]
impl UserRepository for PostgresUserRepository {
    async fn find_all(&self) -> Result<Vec<User>, Box<dyn std::error::Error + Send + Sync>> {
        let models = users::Entity::find()
            .all(self.db.as_ref())
            .await?;

        Ok(models
            .into_iter()
            .map(User::from)
            .collect())
    }

    async fn find_by_id(&self, id: &i64) -> Result<Option<User>, Box<dyn std::error::Error + Send + Sync>> {
        let model = users::Entity::find_by_id(*id)
            .one(self.db.as_ref())
            .await?;

        Ok(model.map(User::from))
    }

    async fn find_by_username(&self, username: &str) -> Result<Option<User>, Box<dyn std::error::Error + Send + Sync>> {
        let model = users::Entity::find()
            .filter(users::Column::Username.eq(username))
            .one(self.db.as_ref())
            .await?;

        Ok(model.map(User::from))
    }

    async fn find_by_email(&self, email: &str) -> Result<Option<User>, Box<dyn std::error::Error + Send + Sync>> {
        let model = users::Entity::find()
            .filter(users::Column::Email.eq(email))
            .one(self.db.as_ref())
            .await?;

        Ok(model.map(User::from))
    }

    async fn create(&self, request: CreateUserRequest) -> Result<User, Box<dyn std::error::Error + Send + Sync>> {
        // Generate salt (using UUID as salt)
        let salt = Uuid::new_v4().to_string();
        let password_hash = hash(&request.password, DEFAULT_COST)?;

        // Convert role to string
        let role_str = match request.role {
            UserRole::Root => "Root",
            UserRole::Admin => "Admin",
            UserRole::User => "User",
        };

        // ID, created_at and updated_at are automatically generated by ActiveModelBehavior
        let active_model = users::ActiveModel {
            username: Set(request.username),
            email: Set(request.email),
            role: Set(role_str.to_string()),
            salt: Set(salt),
            password_hash: Set(password_hash),
            ..Default::default()
        };

        let model = active_model.insert(self.db.as_ref()).await?;

        Ok(User::from(model))
    }

    async fn update(&self, id: &i64, user: User) -> Result<Option<User>, Box<dyn std::error::Error + Send + Sync>> {
        let model = users::Entity::find_by_id(*id)
            .one(self.db.as_ref())
            .await?;

        if let Some(model) = model {
            let mut active_model: users::ActiveModel = model.into();
            active_model.username = Set(user.username);
            active_model.email = Set(user.email);
            active_model.role = Set(match user.role {
                UserRole::Root => "Root",
                UserRole::Admin => "Admin",
                UserRole::User => "User",
            }.to_string());
            // updated_at is automatically updated by ActiveModelBehavior::before_save

            let updated = active_model.update(self.db.as_ref()).await?;

            Ok(Some(User::from(updated)))
        } else {
            Ok(None)
        }
    }

    async fn delete(&self, id: &i64) -> Result<bool, Box<dyn std::error::Error + Send + Sync>> {
        let result = users::Entity::delete_by_id(*id)
            .exec(self.db.as_ref())
            .await?;

        Ok(result.rows_affected > 0)
    }
}

/// Verify password
pub fn verify_password(password: &str, hash: &str) -> Result<bool, bcrypt::BcryptError> {
    verify(password, hash)
}

/// Hash password
pub fn hash_password(password: &str) -> Result<String, bcrypt::BcryptError> {
    hash(password, DEFAULT_COST)
}