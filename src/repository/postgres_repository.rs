use crate::dto::{CreatePostRequest, Post};
use crate::entity::posts;
use crate::repository::PostRepository;
use async_trait::async_trait;
use chrono::Utc;
use sea_orm::{ActiveModelTrait, ColumnTrait, DatabaseConnection, EntityTrait, QueryFilter, QueryOrder, Set};
use std::sync::Arc;

/// PostgreSQL implementation of post repository (using SeaORM)
pub struct PostgresPostRepository {
    db: Arc<DatabaseConnection>,
}

impl PostgresPostRepository {
    pub fn new(db: DatabaseConnection) -> Self {
        Self { db: Arc::new(db) }
    }
}

#[async_trait]
impl PostRepository for PostgresPostRepository {
    async fn find_all(&self) -> Result<Vec<Post>, Box<dyn std::error::Error + Send + Sync>> {
        let models = posts::Entity::find()
            .filter(posts::Column::DeletedAt.is_null())
            .order_by_desc(posts::Column::CreatedAt)
            .all(self.db.as_ref())
            .await?;

        Ok(models.into_iter().map(Post::from).collect())
    }

    async fn find_by_id(
        &self,
        id: &i64,
    ) -> Result<Option<Post>, Box<dyn std::error::Error + Send + Sync>> {
        let model = posts::Entity::find_by_id(*id).one(self.db.as_ref()).await?;

        Ok(model.map(Post::from))
    }

    async fn create(
        &self,
        request: CreatePostRequest,
    ) -> Result<Post, Box<dyn std::error::Error + Send + Sync>> {
        // ID, created_at and updated_at are automatically generated by ActiveModelBehavior
        // Only need to set business fields
        let active_model = posts::ActiveModel {
            // id is not set, automatically generated by ActiveModelBehavior::before_save as UUID
            title: Set(request.title),
            content: Set(request.content),
            category: Set(request.category),
            author_id: Set(request.author_id),
            // created_at and updated_at are automatically set by ActiveModelBehavior
            // archived_at and deleted_at default to None
            ..Default::default()
        };

        let model = active_model.insert(self.db.as_ref()).await?;

        Ok(Post::from(model))
    }

    async fn update(
        &self,
        id: &i64,
        post: Post,
    ) -> Result<Option<Post>, Box<dyn std::error::Error + Send + Sync>> {
        // Convert i64 to Uuid (posts table id is Uuid type)
        let model = posts::Entity::find_by_id(*id).one(self.db.as_ref()).await?;

        if let Some(model) = model {
            let mut active_model: posts::ActiveModel = model.into();
            active_model.title = Set(post.title);
            active_model.content = Set(post.content);
            active_model.category = Set(post.category);
            active_model.author_id = Set(post.author_id);
            // updated_at is automatically updated by ActiveModelBehavior::before_save
            active_model.archived_at = Set(post.archived_at);
            active_model.deleted_at = Set(post.deleted_at);

            let updated = active_model.update(self.db.as_ref()).await?;

            Ok(Some(Post::from(updated)))
        } else {
            Ok(None)
        }
    }

    async fn delete(&self, id: &i64) -> Result<bool, Box<dyn std::error::Error + Send + Sync>> {
        let record = posts::Entity::find_by_id(*id).one(self.db.as_ref()).await?;
        if let Some(record) = record {
            let mut active_model: posts::ActiveModel = record.into();
            active_model.deleted_at = Set(Some(Utc::now().into()));
            active_model.update(self.db.as_ref()).await?;
            Ok(true)
        } else {
            Ok(false)
        }
    }

    async fn archive(&self, id: &i64) -> Result<bool, Box<dyn std::error::Error + Send + Sync>> {
        let record = posts::Entity::find_by_id(*id).one(self.db.as_ref()).await?;
        if let Some(record) = record {
            let mut active_model: posts::ActiveModel = record.into();
            active_model.archived_at = Set(Some(Utc::now().into()));
            active_model.update(self.db.as_ref()).await?;
            Ok(true)
        } else {
            Ok(false)
        }
    }

    async fn restore(&self, id: &i64) -> Result<bool, Box<dyn std::error::Error + Send + Sync>> {
        let record = posts::Entity::find_by_id(*id).one(self.db.as_ref()).await?;
        if let Some(record) = record {
            let mut active_model: posts::ActiveModel = record.into();
            active_model.archived_at = Set(None);
            active_model.deleted_at = Set(None);
            active_model.update(self.db.as_ref()).await?;
            Ok(true)
        } else {
            Ok(false)
        }
    }

    async fn hard_delete(&self, id: &i64) -> Result<bool, Box<dyn std::error::Error + Send + Sync>> {
        let result = posts::Entity::delete_by_id(*id).exec(self.db.as_ref()).await?;
        Ok(result.rows_affected > 0)
    }
}
